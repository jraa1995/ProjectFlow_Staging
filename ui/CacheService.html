<script>
const CacheService = {
  DB_NAME: 'ProjectFlowCache',
  DB_VERSION: 1,
  STORE_NAME: 'cache',
  TTL: {
    tasks: 5 * 60 * 1000,
    projects: 10 * 60 * 1000,
    users: 15 * 60 * 1000,
    config: 30 * 60 * 1000,
    board: 5 * 60 * 1000
  },
  db: null,
  isInitialized: false,
  initPromise: null,
  memoryCache: new Map(),

  async init() {
    if (this.isInitialized && this.db) {
      return this.db;
    }

    if (this.initPromise) {
      return this.initPromise;
    }

    this.initPromise = new Promise((resolve, reject) => {
      try {
        const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.error);
          this.isInitialized = true;
          this.db = null;
          resolve(null);
        };

        request.onsuccess = (event) => {
          this.db = event.target.result;
          this.isInitialized = true;
          resolve(this.db);
        };

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(this.STORE_NAME)) {
            const store = db.createObjectStore(this.STORE_NAME, { keyPath: 'key' });
            store.createIndex('expiry', 'expiry', { unique: false });
          }
        };
      } catch (error) {
        console.error('IndexedDB initialization failed:', error);
        this.isInitialized = true;
        this.db = null;
        resolve(null);
      }
    });

    return this.initPromise;
  },

  async get(key) {
    const memoryItem = this.memoryCache.get(key);
    if (memoryItem && memoryItem.expiry > Date.now()) {
      return memoryItem.data;
    }

    if (memoryItem) {
      this.memoryCache.delete(key);
    }

    await this.init();

    if (!this.db) {
      return null;
    }

    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction([this.STORE_NAME], 'readonly');
        const store = transaction.objectStore(this.STORE_NAME);
        const request = store.get(key);

        request.onsuccess = (event) => {
          const result = event.target.result;
          if (!result) {
            resolve(null);
            return;
          }

          if (result.expiry < Date.now()) {
            this.delete(key);
            resolve(null);
            return;
          }

          this.memoryCache.set(key, {
            data: result.data,
            expiry: result.expiry
          });

          resolve(result.data);
        };

        request.onerror = (event) => {
          console.error('IndexedDB get error:', event.target.error);
          resolve(null);
        };
      } catch (error) {
        console.error('Cache get error:', error);
        resolve(null);
      }
    });
  },

  async set(key, data, ttl = null) {
    const effectiveTtl = ttl || this.TTL[key] || 5 * 60 * 1000;
    const expiry = Date.now() + effectiveTtl;

    this.memoryCache.set(key, { data, expiry });

    await this.init();

    if (!this.db) {
      return true;
    }

    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');
        const store = transaction.objectStore(this.STORE_NAME);

        const item = {
          key: key,
          data: data,
          expiry: expiry,
          createdAt: Date.now()
        };

        const request = store.put(item);

        request.onsuccess = () => {
          resolve(true);
        };

        request.onerror = (event) => {
          console.error('IndexedDB set error:', event.target.error);
          resolve(false);
        };
      } catch (error) {
        console.error('Cache set error:', error);
        resolve(false);
      }
    });
  },

  async delete(key) {
    this.memoryCache.delete(key);

    await this.init();

    if (!this.db) {
      return true;
    }

    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');
        const store = transaction.objectStore(this.STORE_NAME);
        const request = store.delete(key);

        request.onsuccess = () => {
          resolve(true);
        };

        request.onerror = (event) => {
          console.error('IndexedDB delete error:', event.target.error);
          resolve(false);
        };
      } catch (error) {
        console.error('Cache delete error:', error);
        resolve(false);
      }
    });
  },

  async clear() {
    this.memoryCache.clear();

    await this.init();

    if (!this.db) {
      return true;
    }

    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');
        const store = transaction.objectStore(this.STORE_NAME);
        const request = store.clear();

        request.onsuccess = () => {
          resolve(true);
        };

        request.onerror = (event) => {
          console.error('IndexedDB clear error:', event.target.error);
          resolve(false);
        };
      } catch (error) {
        console.error('Cache clear error:', error);
        resolve(false);
      }
    });
  },

  async invalidate(keys) {
    await Promise.all(keys.map(key => this.delete(key)));
  },

  getStats() {
    return {
      memorySize: this.memoryCache.size,
      isInitialized: this.isInitialized,
      hasIndexedDB: !!this.db
    };
  },

  async cleanup() {
    let cleaned = 0;
    const now = Date.now();

    for (const [key, item] of this.memoryCache.entries()) {
      if (item.expiry < now) {
        this.memoryCache.delete(key);
        cleaned++;
      }
    }

    await this.init();

    if (!this.db) {
      return cleaned;
    }

    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction([this.STORE_NAME], 'readwrite');
        const store = transaction.objectStore(this.STORE_NAME);
        const index = store.index('expiry');
        const range = IDBKeyRange.upperBound(now);
        const request = index.openCursor(range);

        request.onsuccess = (event) => {
          const cursor = event.target.result;
          if (cursor) {
            cursor.delete();
            cleaned++;
            cursor.continue();
          }
        };

        transaction.oncomplete = () => {
          resolve(cleaned);
        };

        transaction.onerror = (event) => {
          console.error('Cache cleanup error:', event.target.error);
          resolve(cleaned);
        };
      } catch (error) {
        console.error('Cache cleanup error:', error);
        resolve(cleaned);
      }
    });
  }
};

async function preloadCache() {
  await CacheService.init();

  const cachedTasks = await CacheService.get('tasks');
  const cachedProjects = await CacheService.get('projects');
  const cachedUsers = await CacheService.get('users');
  const cachedConfig = await CacheService.get('config');

  if (cachedTasks) {
    State.setTasks(cachedTasks);
  }

  if (cachedProjects) {
    State.setProjects(cachedProjects);
  }

  if (cachedUsers) {
    State.setUsers(cachedUsers);
  }

  if (cachedConfig) {
    State.config = cachedConfig;
    if (!State.board) State.board = {};
    State.board.config = cachedConfig;
  }

  setInterval(() => CacheService.cleanup(), 5 * 60 * 1000);

  return {
    hasCache: !!(cachedTasks || cachedProjects || cachedUsers),
    tasks: cachedTasks,
    projects: cachedProjects,
    users: cachedUsers,
    config: cachedConfig
  };
}

async function updateCache(type, data) {
  await CacheService.set(type, data);

  switch (type) {
    case 'tasks':
      State.setTasks(data);
      break;
    case 'projects':
      State.setProjects(data);
      break;
    case 'users':
      State.setUsers(data);
      break;
    case 'config':
      State.config = data;
      if (!State.board) State.board = {};
      State.board.config = data;
      break;
  }
}

async function invalidateDataCache() {
  await CacheService.invalidate(['tasks', 'projects', 'users', 'board']);
  State.invalidateCache();
}

CacheService.init();
</script>
